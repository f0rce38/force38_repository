import json
import xml.etree.ElementTree as ET
import pickle
from abc import ABC, abstractmethod
from enum import Enum
from datetime import datetime
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
import xml.dom.minidom as minidom

# ========== ENUMS ==========
class BookGenre(Enum):
    FICTION = "Fiction"
    SCIENCE = "Science"
    BUSINESS = "Business"
    FANTASY = "Fantasy"
    BIOGRAPHY = "Biography"
    HISTORY = "History"
    TECHNOLOGY = "Technology"
    OTHER = "Other"

class BookFormat(Enum):
    PDF = "PDF"
    EPUB = "EPUB"
    MOBI = "MOBI"
    AZW3 = "AZW3"
    TXT = "TXT"

class UserRole(Enum):
    CUSTOMER = "Customer"
    AUTHOR = "Author"
    ADMIN = "Admin"

class OrderStatus(Enum):
    PENDING = "Pending"
    COMPLETED = "Completed"
    CANCELLED = "Cancelled"

# ========== EXCEPTIONS ==========
class BookStoreError(Exception):
    """Base exception for BookStore system"""
    pass

class ValidationError(BookStoreError):
    """Validation failed"""
    pass

class BookNotAvailableError(BookStoreError):
    """Book is not available"""
    pass

class InsufficientFundsError(BookStoreError):
    """User has insufficient funds"""
    pass

class BookAlreadyPurchasedError(BookStoreError):
    """User already purchased this book"""
    pass

class EmptyCartError(BookStoreError):
    """Shopping cart is empty"""
    pass

class SerializationError(BookStoreError):
    """Serialization/deserialization failed"""
    pass

# ========== SERIALIZATION INTERFACES ==========
class Serializer(ABC):
    """Serializer interface"""
    
    @abstractmethod
    def serialize(self, obj: Any) -> bytes:
        pass
    
    @abstractmethod
    def deserialize(self, data: bytes) -> Any:
        pass

class JSONSerializer(Serializer):
    """JSON serializer implementation"""
    
    def serialize(self, obj: Any) -> bytes:
        try:
            return json.dumps(obj, default=str, indent=2).encode('utf-8')
        except Exception as e:
            raise SerializationError(f"JSON serialization failed: {e}")
    
    def deserialize(self, data: bytes) -> Any:
        try:
            return json.loads(data.decode('utf-8'))
        except Exception as e:
            raise SerializationError(f"JSON deserialization failed: {e}")

class XMLSerializer(Serializer):
    """XML serializer implementation"""
    
    def serialize(self, obj: Any) -> bytes:
        # Simplified - would need proper XML structure
        try:
            root = ET.Element("data")
            root.text = str(obj)
            return ET.tostring(root, encoding='utf-8')
        except Exception as e:
            raise SerializationError(f"XML serialization failed: {e}")
    
    def deserialize(self, data: bytes) -> Any:
        try:
            root = ET.fromstring(data.decode('utf-8'))
            return root.text
        except Exception as e:
            raise SerializationError(f"XML deserialization failed: {e}")

class PickleSerializer(Serializer):
    """Pickle serializer implementation"""
    
    def serialize(self, obj: Any) -> bytes:
        try:
            return pickle.dumps(obj)
        except Exception as e:
            raise SerializationError(f"Pickle serialization failed: {e}")
    
    def deserialize(self, data: bytes) -> Any:
        try:
            return pickle.loads(data)
        except Exception as e:
            raise SerializationError(f"Pickle deserialization failed: {e}")

# ========== UNIVERSAL SERIALIZER ==========
class UniversalSerializer:
    """Universal serializer that can use different formats"""
    
    def __init__(self, serializer: Serializer = None):
        self.serializer = serializer or JSONSerializer()
    
    def save(self, obj: Any, filename: str) -> None:
        """Save object to file"""
        try:
            data = self.serializer.serialize(obj)
            with open(filename, 'wb') as f:
                f.write(data)
        except Exception as e:
            raise SerializationError(f"Save failed: {e}")
    
    def load(self, filename: str) -> Any:
        """Load object from file"""
        try:
            with open(filename, 'rb') as f:
                data = f.read()
            return self.serializer.deserialize(data)
        except Exception as e:
            raise SerializationError(f"Load failed: {e}")

# ========== SERIALIZABLE BASE CLASS ==========
class Serializable(ABC):
    """Abstract base class for serializable objects"""
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """Convert object to dictionary"""
        pass
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Serializable':
        """Create object from dictionary"""
        pass

# ========== SERIALIZATION UTILS ==========
class SerializationUtils:
    """Utility class for serialization operations"""
    
    @staticmethod
    def serialize_to_json(obj: Serializable, filename: str) -> None:
        """Serialize object to JSON file"""
        serializer = JSONSerializer()
        universal = UniversalSerializer(serializer)
        universal.save(obj.to_dict(), filename)
    
    @staticmethod
    def deserialize_from_json(cls: type, filename: str) -> Serializable:
        """Deserialize object from JSON file"""
        serializer = JSONSerializer()
        universal = UniversalSerializer(serializer)
        data = universal.load(filename)
        return cls.from_dict(data)
    
    @staticmethod
    def serialize_to_xml(obj: Serializable, filename: str) -> None:
        """Serialize object to XML file"""
        # Implementation would depend on specific XML structure
        pass
    
    @staticmethod
    def serialize_to_pickle(obj: Serializable, filename: str) -> None:
        """Serialize object using pickle"""
        serializer = PickleSerializer()
        universal = UniversalSerializer(serializer)
        universal.save(obj, filename)

# ========== BOOKSTORE SPECIFIC SERIALIZERS ==========
class BookStoreJSONSerializer:
    """BookStore specific JSON serializer"""
    
    @staticmethod
    def to_dict(obj: Any) -> Dict[str, Any]:
        """Convert to dictionary"""
        if hasattr(obj, 'to_dict'):
            return obj.to_dict()
        return obj
    
    @staticmethod
    def from_dict(cls: type, data: Dict[str, Any]) -> Any:
        """Create from dictionary"""
        if hasattr(cls, 'from_dict'):
            return cls.from_dict(data)
        return data
    
    @staticmethod
    def to_json(obj: Any) -> str:
        """Convert to JSON string"""
        return json.dumps(BookStoreJSONSerializer.to_dict(obj), default=str, indent=2)
    
    @staticmethod
    def from_json(cls: type, json_str: str) -> Any:
        """Create from JSON string"""
        data = json.loads(json_str)
        return BookStoreJSONSerializer.from_dict(cls, data)
    
    @staticmethod
    def save_json(obj: Any, filename: str) -> None:
        """Save to JSON file"""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(BookStoreJSONSerializer.to_json(obj))
    
    @staticmethod
    def load_json(cls: type, filename: str) -> Any:
        """Load from JSON file"""
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return BookStoreJSONSerializer.from_dict(cls, data)

class BookStoreXMLSerializer:
    """BookStore specific XML serializer"""
    
    @staticmethod
    def to_xml_element(obj: Any, element_name: str = "object") -> ET.Element:
        """Convert object to XML element"""
        element = ET.Element(element_name)
        
        if hasattr(obj, 'to_dict'):
            data = obj.to_dict()
            for key, value in data.items():
                child = ET.SubElement(element, str(key))
                if isinstance(value, dict):
                    # Recursively handle nested dictionaries
                    child.append(BookStoreXMLSerializer.to_xml_element(value, "item"))
                elif isinstance(value, list):
                    # Handle lists
                    list_elem = ET.SubElement(child, "list")
                    for item in value:
                        list_elem.append(BookStoreXMLSerializer.to_xml_element(item, "item"))
                else:
                    child.text = str(value)
        else:
            element.text = str(obj)
        
        return element
    
    @staticmethod
    def from_xml_element(element: ET.Element) -> Dict[str, Any]:
        """Create object from XML element"""
        result = {}
        
        for child in element:
            if len(child) > 0:
                # Has children, recursively parse
                if child.tag == "list":
                    result[child.tag] = [
                        BookStoreXMLSerializer.from_xml_element(item) 
                        for item in child
                    ]
                else:
                    result[child.tag] = BookStoreXMLSerializer.from_xml_element(child)
            else:
                result[child.tag] = child.text
        
        return result
    
    @staticmethod
    def save_to_xml(obj: Any, filename: str, root_name: str = "root") -> None:
        """Save object to XML file"""
        root = BookStoreXMLSerializer.to_xml_element(obj, root_name)
        tree = ET.ElementTree(root)
        tree.write(filename, encoding='utf-8', xml_declaration=True)
    
    @staticmethod
    def load_from_xml(filename: str) -> Dict[str, Any]:
        """Load object from XML file"""
        tree = ET.parse(filename)
        root = tree.getroot()
        return BookStoreXMLSerializer.from_xml_element(root)
    
    @staticmethod
    def prettify(xml_filename: str) -> str:
        """Return prettified XML string"""
        dom = minidom.parse(xml_filename)
        return dom.toprettyxml(indent="  ")

# ========== DOMAIN CLASSES ==========
@dataclass
class User(Serializable):
    """Base User class"""
    id: str
    username: str
    email: str
    role: UserRole = UserRole.CUSTOMER
    created_at: datetime = field(default_factory=datetime.now)
    balance: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'role': self.role.value,
            'created_at': self.created_at.isoformat(),
            'balance': self.balance
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'User':
        return cls(
            id=data['id'],
            username=data['username'],
            email=data['email'],
            role=UserRole(data['role']),
            created_at=datetime.fromisoformat(data['created_at']),
            balance=data['balance']
        )

@dataclass
class Author(User):
    """Author class inherits from User"""
    published_books: List[str] = field(default_factory=list)
    biography: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data.update({
            'published_books': self.published_books,
            'biography': self.biography
        })
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Author':
        user_data = {k: v for k, v in data.items() if k not in ['published_books', 'biography']}
        user = super().from_dict(user_data)
        return cls(
            id=user.id,
            username=user.username,
            email=user.email,
            role=user.role,
            created_at=user.created_at,
            balance=user.balance,
            published_books=data.get('published_books', []),
            biography=data.get('biography', "")
        )

@dataclass
class DigitalBook(Serializable):
    """Digital Book class"""
    id: str
    title: str
    author_id: str
    author_name: str
    genre: BookGenre
    formats: List[BookFormat]
    price: float
    description: str = ""
    publication_date: datetime = field(default_factory=datetime.now)
    is_available: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'title': self.title,
            'author_id': self.author_id,
            'author_name': self.author_name,
            'genre': self.genre.value,
            'formats': [f.value for f in self.formats],
            'price': self.price,
            'description': self.description,
            'publication_date': self.publication_date.isoformat(),
            'is_available': self.is_available
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DigitalBook':
        return cls(
            id=data['id'],
            title=data['title'],
            author_id=data['author_id'],
            author_name=data['author_name'],
            genre=BookGenre(data['genre']),
            formats=[BookFormat(f) for f in data['formats']],
            price=data['price'],
            description=data.get('description', ""),
            publication_date=datetime.fromisoformat(data['publication_date']),
            is_available=data.get('is_available', True)
        )

@dataclass
class Review(Serializable):
    """Book Review class"""
    id: str
    book_id: str
    user_id: str
    rating: int  # 1-5
    comment: str
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'book_id': self.book_id,
            'user_id': self.user_id,
            'rating': self.rating,
            'comment': self.comment,
            'created_at': self.created_at.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Review':
        return cls(
            id=data['id'],
            book_id=data['book_id'],
            user_id=data['user_id'],
            rating=data['rating'],
            comment=data['comment'],
            created_at=datetime.fromisoformat(data['created_at'])
        )

@dataclass
class ShoppingCart(Serializable):
    """Shopping Cart class"""
    user_id: str
    items: List[Dict[str, Any]] = field(default_factory=list)  # List of {book_id, format, price}
    
    def add_item(self, book_id: str, book_format: BookFormat, price: float) -> None:
        """Add item to cart"""
        self.items.append({
            'book_id': book_id,
            'format': book_format.value,
            'price': price
        })
    
    def remove_item(self, book_id: str) -> bool:
        """Remove item from cart"""
        for i, item in enumerate(self.items):
            if item['book_id'] == book_id:
                self.items.pop(i)
                return True
        return False
    
    def clear(self) -> None:
        """Clear all items"""
        self.items.clear()
    
    def get_total(self) -> float:
        """Calculate total price"""
        return sum(item['price'] for item in self.items)
    
    def is_empty(self) -> bool:
        """Check if cart is empty"""
        return len(self.items) == 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'user_id': self.user_id,
            'items': self.items
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ShoppingCart':
        cart = cls(user_id=data['user_id'])
        cart.items = data.get('items', [])
        return cart

@dataclass
class Order(Serializable):
    """Order class"""
    id: str
    user_id: str
    items: List[Dict[str, Any]]
    total_amount: float
    status: OrderStatus = OrderStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    def complete(self) -> None:
        """Mark order as completed"""
        self.status = OrderStatus.COMPLETED
        self.completed_at = datetime.now()
    
    def cancel(self) -> None:
        """Cancel order"""
        self.status = OrderStatus.CANCELLED
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'user_id': self.user_id,
            'items': self.items,
            'total_amount': self.total_amount,
            'status': self.status.value,
            'created_at': self.created_at.isoformat(),
            'completed_at': self.completed_at.isoformat() if self.completed_at else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Order':
        return cls(
            id=data['id'],
            user_id=data['user_id'],
            items=data['items'],
            total_amount=data['total_amount'],
            status=OrderStatus(data['status']),
            created_at=datetime.fromisoformat(data['created_at']),
            completed_at=datetime.fromisoformat(data['completed_at']) if data.get('completed_at') else None
        )

@dataclass
class BookStore:
    """Main BookStore class"""
    books: List[DigitalBook] = field(default_factory=list)
    users: List[User] = field(default_factory=list)
    orders: List[Order] = field(default_factory=list)
    
    def add_book(self, book: DigitalBook) -> None:
        """Add book to store"""
        self.books.append(book)
    
    def add_user(self, user: User) -> None:
        """Add user to store"""
        self.users.append(user)
    
    def find_book(self, book_id: str) -> Optional[DigitalBook]:
        """Find book by ID"""
        for book in self.books:
            if book.id == book_id:
                return book
        return None
    
    def find_user(self, user_id: str) -> Optional[User]:
        """Find user by ID"""
        for user in self.users:
            if user.id == user_id:
                return user
        return None
    
    def purchase(self, user_id: str, cart: ShoppingCart) -> Order:
        """Process purchase from shopping cart"""
        if cart.is_empty():
            raise EmptyCartError("Cannot purchase empty cart")
        
        user = self.find_user(user_id)
        if not user:
            raise ValidationError(f"User {user_id} not found")
        
        if user.balance < cart.get_total():
            raise InsufficientFundsError(f"Insufficient funds. Balance: {user.balance}, Total: {cart.get_total()}")
        
        # Check if books are available
        for item in cart.items:
            book = self.find_book(item['book_id'])
            if not book or not book.is_available:
                raise BookNotAvailableError(f"Book {item['book_id']} is not available")
        
        # Create order
        order = Order(
            id=f"ORD-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            user_id=user_id,
            items=cart.items.copy(),
            total_amount=cart.get_total()
        )
        
        # Process payment
        user.balance -= order.total_amount
        
        # Update books availability if needed
        for item in order.items:
            book = self.find_book(item['book_id'])
            if book:
                book.is_available = False
        
        # Add order to store
        self.orders.append(order)
        
        # Clear cart
        cart.clear()
        
        return order

# ========== USAGE EXAMPLE ==========
def example_usage():
    """Example of how to use the BookStore system"""
    
    # Create some users
    author = Author(
        id="auth-001",
        username="jane_author",
        email="jane@example.com",
        role=UserRole.AUTHOR,
        balance=100.0,
        biography="Best-selling author"
    )
    
    customer = User(
        id="user-001",
        username="john_doe",
        email="john@example.com",
        role=UserRole.CUSTOMER,
        balance=50.0
    )
    
    # Create books
    book = DigitalBook(
        id="book-001",
        title="Python Programming",
        author_id=author.id,
        author_name=author.username,
        genre=BookGenre.TECHNOLOGY,
        formats=[BookFormat.PDF, BookFormat.EPUB],
        price=29.99,
        description="Learn Python programming"
    )
    
    # Create bookstore
    store = BookStore()
    store.add_user(author)
    store.add_user(customer)
    store.add_book(book)
    
    # Create shopping cart
    cart = ShoppingCart(user_id=customer.id)
    cart.add_item(book.id, BookFormat.PDF, book.price)
    
    print(f"Cart total: ${cart.get_total():.2f}")
    print(f"Customer balance: ${customer.balance:.2f}")
    
    # Try to purchase
    try:
        order = store.purchase(customer.id, cart)
        print(f"Order created: {order.id}")
        print(f"Order status: {order.status.value}")
        print(f"Customer new balance: ${customer.balance:.2f}")
    except BookStoreError as e:
        print(f"Purchase failed: {e}")
    
    # Serialize to JSON
    print("\n=== JSON Serialization ===")
    json_str = BookStoreJSONSerializer.to_json(book)
    print(f"Book as JSON:\n{json_str[:200]}...")
    
    # Save to file
    BookStoreJSONSerializer.save_json(book, "book.json")
    
    # Load from file
    loaded_book = BookStoreJSONSerializer.load_json(DigitalBook, "book.json")
    print(f"\nLoaded book title: {loaded_book.title}")
    
    # Universal serializer
    print("\n=== Universal Serializer ===")
    serializer = UniversalSerializer(JSONSerializer())
    serializer.save(customer, "customer.json")
    
    # XML Serialization
    print("\n=== XML Serialization ===")
    BookStoreXMLSerializer.save_to_xml(book, "book.xml", "digital_book")
    pretty_xml = BookStoreXMLSerializer.prettify("book.xml")
    print(f"XML preview:\n{pretty_xml[:300]}...")

if __name__ == "__main__":
    example_usage()
